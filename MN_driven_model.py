""" 
Author: Arnault CAILLET
arnault.caillet17@imperial.ac.uk
July 2023
Imperial College London
Department of Civil Engineering
This code produces the results presented in the manuscript Caillet et al. 'Motoneuron-driven computational muscle modelling with motor unit resolution and subject-specific musculoskeletal anatomy' (2023)
---------

In brief, input motoneuron (MN) spike trains are transformed with the MN-driven model into motor unit (MU) Forces (FMU), that sum to yield the total muscle force.

Five experimental datsets are available ('test'), recorded at 30% and 50%MVC with 36, 64, and 256 EMG electrodes (increasing electrode density)
The model is either driven ('Input_MU_pop') by the Nr experimental spike trains (Nr) or by the 400 MN spike trains of the completely reconstructed MU pool (400) derived with https://doi.org/10.1371/journal.pcbi.1010556
In case of Nr inputs, the distribution of the MU's max iso forces (F0MU) follows two different approaches (f0_MU_distrib = 'evenly' or 'identified') (please see manuscript for details)


Key Parameters
----------
$ exp_disch_times: Experimental MN spike trains infered from decomposed HDEMG signals
$ Firing_times_sim: MN spike trains for the completely reconstructed pool of MNs, derived from exp_disch_times with the computational method published at https://doi.org/10.1371/journal.pcbi.1010556
$ Transd_Force: Experimental ankle force (in V) recorded with a force transducer

Key returns
-------
$ F_MU_list: Time-histories of the predicted MU forces (in N)
$ Tot_Muscle_force: Prediction of the whole muscle force as the sum of the individual simulated MU forces (in N)
$ Exp_muscle_force: For validation, Experimental TA force, infered from Transd_Force and an offline estimation of the co-torque generated by the co-contracting agonist and antagonist muscles

Intermediary returns
-------

$ F0MU_distribution: Distribution of the F0MU values (in N) across the MU sample
$ MN_AP_list: Time-histories of MN action potentials
$ MU_AP_list: Time-histories of MU action potentials
$ free_Ca_concentration_list: Time-histories of free Calcium concentration in the MU sarcoplasm
$ bound_Ca_concentration_list: Time-histories of Calcium-Troponin concentration in the MUs
$ act_histories_list: Time-histories of MU active states
$ normalized_FL_force_list: Time-histories of MU FL scaling factor (Force-Length relaitonship)

"""

#------------------------------------------------------------------------------
# User Definition

### AVAILABLE EXPERIMENTAL DATASETS OF INPUT SPIKE TRAINS (to uncomment)
# test = 'S1_30_256' #30% MVC - 256 electrodes
# test = 'S1_30_64L'
# test = 'S1_30_36L'
test = 'S1_50_256'
# test = 'S1_50_64L'

### TYPE OF NEURAL INPUTS (experimental or reconstructed)
Input_MU_pop='Nr' # the inputs are the Nr experimental spike trains
# Input_MU_pop='400' # the inputs are the spike trains of the reconstructed population of 400 MUs

### If Input_MU_pop='Nr', type of distribution chosen for the f0^MU parameter 
f0_MU_distrib = 'evenly'  # Evenly distributed across pool
# f0_MU_distrib = 'identified' # identified with recruitment threshold

### Accounting for the electromechanical delays?
delay ='y'
# delay = 'n'

### Requires storing the histories of APs, free Ca, and CaTn?
want_all_intermediary_data = 'n'

### Saving the simulations?
# save = 'y'
save='n'













#------------------------------------------------------------------------------

from IPython import get_ipython;   
get_ipython().magic('reset -sf')
import sys
sys.path.insert(0,'Modules/')
from pathlib import Path
root = Path(".")
path_to_data = root / "Results"

#------------------------------------------------------------------------------
# Libraries and functions
import numpy as np
import matplotlib.pyplot as plt
from load_Input_Data_MOD import load_Input_Data_func
from input_spike_trains_MOD import input_spike_trains_func
from F_TA_MOD import F_TA_func
from MU_type_id_MOD import MU_type_id_func
from MN_AP_MOD import MN_AP_func
from MU_AP_MOD import MU_AP_func
from MU_free_Ca_MOD import MU_free_Ca_func
from MU_bound_calcium_MOD import MU_bound_calcium_func
from MU_active_state_MOD import MU_active_state_func
from Force_Length_MOD import Force_Length_func
from F0MU_distrib_MOD import F0MU_distrib_func
from fibre_forces_MOD import fibre_forces_func

#------------------------------------------------------------------------------
# Loading the pre-processed Experimental (Nr MUs) and reconstructed (N = 400 MUs) populations of MU spike trains + additional parameters 
time, time_dt, muscle, MVC, Transd_Force, muscle_F0M, Nb_MN, MN_pop, Real_MN_pop, exp_disch_times, Firing_times_sim, range_start,range_stop, t_start, plateau_time1, plateau_time2, end_force, d, dt, fs = load_Input_Data_func(test, path_to_data)

# Re-sizing the input matrix of MU discharge times, also converted from samples into seconds 
Nr, sp_matrix = input_spike_trains_func(Input_MU_pop, Nb_MN, Firing_times_sim, exp_disch_times, fs)
print('There are ', Nr, ' discharging MUs in this simulation.')

#------------------------------------------------------------------------------
# 0. Experimental Muscle Force from Experimental Force Transducer and Muscle Co-Contraction (bEMG)
Exp_muscle_force, F_TA_norm = F_TA_func(Transd_Force, MVC, fs, range_start, range_stop, plateau_time1, plateau_time2)
#------------------------------------------------------------------------------

#------------------------------------------------------------------------------
# 0. F0MU distribution across the sample of MUs
F0MU_distribution = F0MU_distrib_func(MVC, Nr, MN_pop, muscle_F0M, Input_MU_pop, Real_MN_pop, f0_MU_distrib)
#------------------------------------------------------------------------------



###############################################################################
# RUNNING THE MN-DRIVEN MODEL FOR ALL FIRING MUS USED AS INPUTS

#------------------------------------------------------------------------------
# Array initialization 
if want_all_intermediary_data =='y': 
    MN_AP_list = np.empty((Nr,len(time_dt)), dtype=object) 
    MU_AP_list = np.empty((Nr,), dtype=object)     
    free_Ca_concentration_list = np.empty((Nr,), dtype=object) 
    bound_Ca_concentration_list = np.empty((Nr,), dtype=object) 
act_histories_list = np.empty((Nr,), dtype=object) 
normalized_FL_force_list = np.empty((Nr,), dtype=object) 

#------------------------------------------------------------------------------
#------------------------------------------------------------------------------
#------------------------------------------------------------------------------
#------------------------------------------------------------------------------   
# Running the simulation to get the normalized generated force each MU
for i in range (Nr): # for each considered MU 
    print('Computing Force for MU nÂ°', str(i+1))

#-----------------------
# 1. MU type identification (slow / fast)
    MU_type = MU_type_id_func(i, Input_MU_pop, f0_MU_distrib, Real_MN_pop, Nr)

#---------------------
# 2. MU normalized length        
    l_M_norm=1.16 # Normalized fibre length identified in the study
    l_M_norm_list=l_M_norm*np.ones(Nr) #Assuming for the activation dynamics that all MUs are at optimal fibre length


#-------------
### 3. EXCITATION DYNAMICS
# 3.0.MN discharge times 
    Matrix_AP = sp_matrix[i].astype(float) #Array of discharge times [s] for MU i

#-----------------------
# 3.1. Nerve AP = f(discharge times)
    if want_all_intermediary_data =='y':
        for j in range (len(time_dt)):
            MN_AP_list[i][j] = MN_AP_func(time_dt[j], Matrix_AP)     

#-------------
# 3.2. MU AP = f(MNAP)        
    MU_AP_train = MU_AP_func(d, dt,  Matrix_AP, dt/1, delay)        
    if want_all_intermediary_data =='y': 
        MU_AP_list[i] = MU_AP_train

#----------------
### 4. ACTIVATION DYNAMICS
# 4.1. Free Ca = f(MUAP,l,type) 
    free_Ca_concentration = MU_free_Ca_func(d, dt, MU_AP_train, l_M_norm, MU_type, Matrix_AP, delay)
    if want_all_intermediary_data =='y': free_Ca_concentration_list[i] = free_Ca_concentration

#----------------
# 4.2. CaTn = f(Ca,type)             
    bound_Ca_concentration = MU_bound_calcium_func(d, dt, free_Ca_concentration, l_M_norm, MU_type, Matrix_AP)
    if want_all_intermediary_data =='y': bound_Ca_concentration_list[i] = bound_Ca_concentration

#----------------
# 4.3. act = f(CaTn, type)  
    active_state = MU_active_state_func(d, dt, bound_Ca_concentration, l_M_norm, MU_type, Matrix_AP)    
    act_histories_list[i] = active_state # Storing results

#----------------
### 5. CONTRACTION DYNAMICS
# 5.1. f_FL = f(act, lMnorm) 
    normalized_FL_force_list[i]= Force_Length_func(l_M_norm_list[i],active_state)

#------------------------------------------------------------------------------
### NORMALIZED MU FORCES
# 6. f_MU_norm = f(a, f_FL)
normalized_MU_Force_list = act_histories_list * normalized_FL_force_list 
Normalized_MU_Force_list = fibre_forces_func(Nr, muscle_F0M, F0MU_distribution, normalized_MU_Force_list) #accounting for the individual asynchronous activities of the fibres constituting the MUs

#------------------------------------------------------------------------------
### MU FORCES (N)
# 7. f_MU = f(f_MU_norm, f0MU)
F_MU_list = F0MU_distribution * Normalized_MU_Force_list

#------------------------------------------------------------------------------
### 9. Total muscle force (N)
Tot_Muscle_force=F_MU_list.sum(axis=0) # Total whole muscle force (in N)


#------------------------------------------------------------------------------
#------------------------------------------------------------------------------
#------------------------------------------------------------------------------


#------------------------------------------------------------------------------
# Visual validation
plt.rcParams['figure.dpi'] = 360
plt.plot(time_dt, Tot_Muscle_force, 'r', label='Simulated Force')
plt.plot(time, Exp_muscle_force, 'k', label='Experimental Force')
plt.xlim(0, end_force)
plt.ylim(0, max(np.max(Exp_muscle_force), np.max(Tot_Muscle_force))*1.1)
plt.xlabel('Time [s]')
plt.ylabel('TA Force (N)')
plt.legend()
plt.grid()
plt.show()

#------------------------------------------------------------------------------
# Saving data
if save =='y':
    if Input_MU_pop=='400': 
        k='400_'
        prefix = k+test+'_'
    else: 
        k='Nr_'
        prefix = k+test+'_'+f0_MU_distrib+'_'
    np.save(prefix+'time_sim', time_dt, allow_pickle=True) 
    np.save(prefix+'time_exp', time, allow_pickle=True) 
    np.save(prefix+'MU_act_list', act_histories_list, allow_pickle=True) 
    np.save(prefix+'MU_force_list', F_MU_list, allow_pickle=True) 
    np.save(prefix+'F0MU_distrib', F0MU_distribution, allow_pickle=True) 
    np.save(prefix+'total_muscle_force', Tot_Muscle_force, allow_pickle=True)
    np.save(prefix+'scaled_exp_force_in_N', Exp_muscle_force, allow_pickle=True) 
    
    if want_all_intermediary_data == 'y':
        np.save(prefix+'MNAP_list', MN_AP_list, allow_pickle=True) 
        np.save(prefix+'MUAP_list', MU_AP_list, allow_pickle=True) 
        np.save(prefix+'freeCa_list', free_Ca_concentration_list, allow_pickle=True) 
        np.save(prefix+'boundCa_list', bound_Ca_concentration_list, allow_pickle=True)         
    